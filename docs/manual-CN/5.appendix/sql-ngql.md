# SQL 和 nGQL

## 基本概念对比

|概念名称               | SQL | nGQL          |
| --- | --- | --- |
| vertex      | \  | vertex        |
| edge | \    | edge          |
| vertex type        | \   | tag           |
| edge type          | \  | edge type     |
| vertex identifier          | \ | vid           |
| edge identifier        | edge id generated by default   | src, dst, rank  |
| column | column | \ |
| row | row | \ |

## 基本操作

操作                    | SQL                   | nGQL
-------------------------| ------------------------ | -----------
创建图空间（数据库）              | CREATE DATABASE `<database_name>`                    | CREATE SPACE `<space_name>`
列出图空间（数据库）          | SHOW DATABASES | SHOW SPACES
使用图空间（数据库）  | USE `<database_name>` | USE `<space_name>`
创建 tag | \ | CREATE TAG `<tag_name>`
创建 edge | \ | CREATE EDGE `<edge_name>`
创建 table | CREATE TABLE `<tbl_name>` (create_definition,...) | \
列出 columns | SHOW COLUMNS FROM `<tbl_name>` | \
列出 tags/edges | \ | SHOW TAGS \| EDGES
列出 tags/edges 属性| \ | DESCRIBE TAG \| EDGE `<tag_name | edge_name>`
插入数据 | INSERT INTO `<tbl_name>` [(col_name [, col_name] ...)] {VALUES \| VALUE} [(value_list) [, (value_list)] | INSERT VERTEX `<tag_name>` (prop_name_list[, prop_name_list]) {VALUES \| VALUE} vid: (prop_value_list[, prop_value_list]) <br/> INSERT EDGE `<edge_name>` ( `<prop_name_list>` ) VALUES \| VALUE `<src_vid>` -> `<dst_vid>`[`@<rank>`] : ( `<prop_value_list>` )
查询数据 | SELECT | GO, FETCH
更新数据 | UPDATE `<tbl_name>` SET field1=new-value1, field2=new-value2 [WHERE Clause] | UPDATE VERTEX `<vid>` SET `<update_columns>` [WHEN `<condition>`] <br/> UPDATE EDGE `<edge>` SET `<update_columns>` [WHEN `<condition>`]
删除数据 | DELETE FROM `<tbl_name>` [WHERE Clause] | DELETE EDGE `<edge_type>` `<vid>` -> `<vid>`[`@<rank>`] [, `<vid>` -> `<vid>` ...] <br/> DELETE VERTEX `<vid_list>`

## Sample Queries

This section gives some query examples for your reference.

### Query 1

Find the player in the `player` table whose id is 100 and output the `name` property in RDBMS:

```sql
SELECT player.name
FROM player
WHERE player.id = 100;
```

```ngql
nebula> FETCH PROP ON player 100 YIELD player.name;
```

### Query 2

Find players who are younger than 36.

```sql
SELECT player.name
FROM player
WHERE player.age < 36;
```

The query in nGQL is a bit different because we need to create an index before filtering a property. See [Index Doc](https://docs.nebula-graph.io/manual-EN/2.query-language/4.statement-syntax/1.data-definition-statements/) for more information.

```ngql
nebula> CREATE TAG INDEX player_age ON player(age);
nebula> REBUILD TAG INDEX player_age OFFLINE;
nebula> LOOKUP ON player WHERE player.age < 36;
```

### Query 3

List Tim Duncan and the team he served.

```sql
SELECT a.id, a.name, c.name
FROM player a
JOIN serve b ON a.id=b.player_id
JOIN team c ON c.id=b.team_id
WHERE a.name = 'Tim Duncan';
```

```ngql
nebula> CREATE TAG INDEX player_name ON player(name);
nebula> REBUILD TAG INDEX player_name OFFLINE;
nebula> LOOKUP ON player WHERE player.name == 'Tim Duncan' YIELD player.name AS name | GO FROM $-.VertexID OVER serve YIELD $-.name, $$.team.name;
```

### Query 4

Search Tim Duncan's player mates.

```sql
SELECT a.id, a.name, c.name
FROM player a
JOIN serve b ON a.id=b.player_id
JOIN team c ON c.id=b.team_id
WHERE c.name IN (SELECT c.name
FROM player a
JOIN serve b ON a.id=b.player_id
JOIN team c ON c.id=b.team_id
WHERE a.name = 'Tim Duncan');
```

In nGQL we use pipe as the input of the second clause in this case.

```ngql
nebula> GO FROM 100 OVER serve YIELD serve._dst AS Team | GO FROM $-.Team OVER serve REVERSELY YIELD $$.player.name;
```
