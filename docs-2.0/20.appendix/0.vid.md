# 点VID

在Nebula Graph中，一个点由点的ID唯一标识，即VID或Vertex ID。

## VID有如下特点

- VID数据类型只可以为定长字符串`FIXED_STRING(<N>)`或64位整数；一个图空间只能选用其中一种VID类型。

- VID在一个图空间中必须唯一，其作用类似于关系型数据库中的主键（索引+唯一约束）。但不同图空间中的VID是完全独立无关的。

- 点VID的生成方式必须由用户自行指定，系统不提供自增ID或者UUID。

- VID相同的点，会被认为是同一个点。例如：
  
  + VID相当于一个实体的唯一标号，例如一个人的身份证号。标签（Tag）相当于实体所拥有的类型，例如滴滴司机和老板。不同的Tag又相应定义了几组不同的属性，例如工号、薪水、商务手机号、债务额度。

  + 同时操作相同VID并且相同Tag的两条`INSERT`语句，晚写入的`INSERT`会覆盖先写入的。

  + 同时操作包含相同VID但是两个不同`TAG A`和`TAG B`的两条`INSERT`语句，对`TAG A`的操作不会影响`TAG B`。

-  VID通常会被索引（LSM-tree方式）并缓存在内存中，因此直接访问VID的性能最高。（属性本身则需通过属性索引功能)

## VID 使用建议

- Nebula Graph 1.x只支持VID为int64。2.x默认使用`FIXED_STRING(<N>)`为VID类型；但在`CREATE SPACE`中通过参数`vid_type = int64`，也可设置为64位整数。

- 可以使用`id()`函数，指定或引用该点的VID；

- 可以使用`LOOKUP`或者`MATCH`语句，来通过属性索引查找对应的VID;

- 性能上，直接通过VID找到点的语句性能最高，例如`DELETE xxx WHERE id(xxx) == "player100"`, 或者`GO FROM "player100"`等语句。通过属性先查找VID，再进行图操作的性能会变差，例如`LOOKUP | GO FROM $-.ids`等语句，相比前者多了一次内存或硬盘的随机读（`LOOKUP`）以及一次序列化（`|`）。

## VID 生成建议 

VID 的生成工作完全交给应用端，有一些通用的建议：

- （最优）通过有唯一性的主键或者属性来直接作为VID；属性访问依赖于VID;

- 通过有唯一性的属性组合来生成VID，属性访问依赖于属性索引。

- 通过snowflake等算法生成VID，属性访问依赖于属性索引;

- 如果个别记录的主键特别长，但绝大多数记录的主键都很短的情况，不要将`FIXED_STRING(<N>)`的`N`设置成超大，这会浪费大量内存和硬盘，也会降低性能。此时可通过BASE64，MD5，hash编码加拼接的方式来生成。

- 如果用hash方式生成int64 VID，在有10亿个点的情况下，发生碰撞的概率大约是1/10。边的数量与碰撞的概率无关。

