# 点VID

<<<<<<< HEAD
在Nebula Graph中，一个点由点的ID唯一标识，即VID或Vertex ID。

## VID 的特点

- VID数据类型只可以为定长字符串`FIXED_STRING(<N>)`或64位整数；一个图空间只能选用其中一种VID类型。

- VID在一个图空间中必须唯一，其作用类似于关系型数据库中的主键（索引+唯一约束）。但不同图空间中的VID是完全独立无关的。

- 点VID的生成方式必须由用户自行指定，系统不提供自增ID或者UUID。

- VID相同的点，会被认为是同一个点。例如：
  
  + VID相当于一个实体的唯一标号，例如一个人的身份证号。标签（Tag）相当于实体所拥有的类型，例如滴滴司机和老板。不同的Tag又相应定义了几组不同的属性，例如工号、薪水、商务手机号、债务额度。

  + 同时操作相同VID并且相同Tag的两条`INSERT`语句，晚写入的`INSERT`会覆盖先写入的。

  + 同时操作包含相同VID但是两个不同`TAG A`和`TAG B`的两条`INSERT`语句，对`TAG A`的操作不会影响`TAG B`。

-  VID通常会被索引（LSM-tree方式）并缓存在内存中，因此直接访问VID的性能最高。（属性本身则需通过属性索引功能)

## VID使用建议

- Nebula Graph 1.x只支持VID为int64。2.x默认使用`FIXED_STRING(<N>)`为VID类型；但在`CREATE SPACE`中通过参数`vid_type = int64`，也可设置为64位整数。

- 可以使用`id()`函数，指定或引用该点的VID；

- 可以使用`LOOKUP`或者`MATCH`语句，来通过属性索引查找对应的VID;

- 性能上，直接通过VID找到点的语句性能最高，例如`DELETE xxx WHERE id(xxx) == "player100"`, 或者`GO FROM "player100"`等语句。通过属性先查找VID，再进行图操作的性能会变差，例如`LOOKUP | GO FROM $-.ids`等语句，相比前者多了一次内存或硬盘的随机读（`LOOKUP`）以及一次序列化（`|`）。

## VID生成建议 

VID的生成工作完全交给应用端，有一些通用的建议：

- （最优）通过有唯一性的主键或者属性来直接作为VID；属性访问依赖于VID;

- 通过有唯一性的属性组合来生成VID，属性访问依赖于属性索引。

- 通过snowflake等算法生成VID，属性访问依赖于属性索引;

- 如果个别记录的主键特别长，但绝大多数记录的主键都很短的情况，不要将`FIXED_STRING(<N>)`的`N`设置成超大，这会浪费大量内存和硬盘，也会降低性能。此时可通过BASE64，MD5，hash编码加拼接的方式来生成。

- 如果用hash方式生成int64 VID，在有10亿个点的情况下，发生碰撞的概率大约是1/10。边的数量与碰撞的概率无关。
=======
在Nebula Graph中，一个点是由点的ID唯一标识 (称为`VID`，也有些语句也会称为`VertexID`)。

## VID 的特点

- `VID`数据类型只可以为定长字符串`FIX_STRING(N)`或64位整数；一个图空间只能选用其中一种 VID 类型。

- `VID`在一个图空间中必须唯一，其作用大体类似于关系型数据库中的“主键(索引+唯一约束)”。但不同图空间中的 `VID` 是完全独立无关的。

- `VID` 相同的点，会被认为是同一个点。操作相同`VID`的两条 `INSERT`语句，晚写入的点会“覆盖”先写入的的点。

- 点`VID`的生成方式必须由用户自行指定，系统不提供`自增ID`或者`UUID`。

- 一个`VID`可以有多个标签（`TAG`）。例如一个人（`VID`）可以有两个不同的角色（`TAG`），不同的 Tag 又相应决定了几组不同的 schema。

-  `VID` 通常会被索引(LSM-tree方式)并缓存在内存中，因此直接访问`VID`的性能最高。(属性本身则基本不会)

## VID 使用建议

- Nebula Graph 1.x 只支持 VID 为 int64。2.x 默认使用 `FIXED_STRING(<N>)` 为 `VID` 类型；但在 `CREATE SPACE` 中通过参数 `vid_type = int64`，也可设置为64位整数。

- 可以使用 `id()` 函数，指定或引用该点的 `VID`；

- 可以使用 `LOOKUP` 或者 `MATCH` 语句，来通过“属性索引”查找对应的 `VID`;

- 性能上，“直接通过`VID`找到点”的语句性能最高：例如 `DELETE ... WHERE id(xxx) == "player100"`, 或者 `GO FROM "player100"` 等语句。“通过属性先查找VID，再进行图操作”的性能会变差：例如 "LOOKUP | GO FROM $-.ids" 等语句，相比前者多了一次内存/硬盘的随机读(`LOOKUP`)以及一次序列化(`|`)。

## VID 生成建议 

VID 的生成工作完全交给应用端，有一些通用的建议：

- (最优)通过有唯一性的主键或者属性来直接作为 `VID`；属性访问依赖于`VID`;

- 通过有唯一性的属性组合来生成 `VID`，属性访问依赖于属性索引。

- 通过 `snowflake` 等算法生成 `VID`，属性访问依赖于属性索引;

- 如果“个别记录的主键特别长，但绝大多数记录的主键都很短”的情况，不要将`FIXED_STRING(<N>)`的`N`设置成超大；这会浪费大量内存和硬盘，也会降低性能。此时可通过 BASE64, MD5, hash 编码 + 拼接的方式来生成。

- 如果用 hash 方式生成 int64 VID：在有 10 亿个点的情况下，发生碰撞的概率大约是 1/10。边的数量与碰撞的概率无关。

>>>>>>> d49fbb9c (fix deploy.yaml)
