# CREATE INDEX

!!! warning 

    索引的概念和使用限制都较为复杂。索引配合`LOOKUP`和`MATCH`语句使用。

`CREATE INDEX`语句用于对Tag、EdgeType或其属性创建原生索引。通常分别称为标签索引、边类型索引和属性索引。

标签索引和边类型索引用于和标签、边类型（自身）相关的查询,而不是基于标签上某属性的查询。例如用 LOOKUP 找到某种边类型E的所有的边。

属性索引目的是基于属性的查询。例如基于属性`Age`找到`Age == 19`的所有的点VID。
    
如果已经为某个标签T的属性A建立过属性索引`i_TA`，则没有必要对于`标签T`额外再建立一个标签索引`i_T`。这是因为查询引擎可以使用`i_TA`来替代`i_T`。边类型索引同理。但是，`i_T`却不能替代`i_TA`用于属性查找。

如何创建全文索引，请参见[部署全文索引](../../4.deployment-and-installation/6.deploy-text-based-index/2.deploy-es.md)。

## 前提条件

创建索引之前，请确保相关的标签或边类型已经创建。如何创建标签和边类型，请参见[CREATE TAG](../10.tag-statements/1.create-tag.md)和[CREATE EDGE](../11.edge-type-statements/1.create-edge.md)。

## 使用索引必读

!!! warning

    不要任意在生产环境中使用索引，除非您很清楚使用索引对业务的影响。索引会导致写性能下降90%甚至更多。索引并不用于查询加速。只用于根据属性定位到点或边，或者统计点边数量。

如果您必须使用索引，通常按照如下步骤：

1. 导入数据至Nebula Graph。

2. 创建索引。

3. [重建索引](4.rebuild-native-index.md)。

4. 使用[LOOKUP](../7.general-query-statements/5.lookup.md)或[MATCH](../7.general-query-statements/2.match.md)语句查询数据。您不需要指定使用哪个索引，Nebula Graph会自动计算。

!!! warning "如果先创建索引再导入数据，会因为写性能的下降导致导入速度极慢。"

!!! danger "创建索引后，必须为已存在的数据重建索引。否则无法在`MATCH`和`LOOKUP`语句中返回这些数据。"

!!! danger "新创建的索引并不会立刻生效"

    创建新的索引并尝试立刻使用(例如`LOOKUP`或者`REBUILD INDEX`)通常会失败（报错`can't find xxx in the space`）。因为创建步骤是异步实现的，Nebula Graph要在下一个心跳周期才能完成索引的创建。可以使用如下方法之一：

   - 在[`SHOW TAG/EDGE INDEXES`](2.show-native-indexes.md)语句的结果中查找到新的索引。或者，

   - 等待两个心跳周期，例如20秒。如果需要修改心跳间隔，请为[所有配置文件](../../5.configurations-and-logs/1.configurations/1.configurations.md)修改参数`heartbeat_interval_secs`。

## 语法

```ngql
CREATE {TAG | EDGE} INDEX [IF NOT EXISTS] <index_name> ON {<tag_name> | <edge_name>} ([prop_name_list]);
```

- `index_name`：索引名。索引名在一个图空间中必须是唯一的。推荐的命名方式为`i_tagName_propName`。

- `IF NOT EXISTS`：检测待创建的索引是否存在，只有不存在时，才会创建索引。

- `prop_name_list`:

  + 为**变长**字符串属性创建索引时，必须用`prop_name(length)`指定索引长度。

  + 为标签或边类型本身创建索引时，忽略`prop_name_list`。

!!! warning "长索引会降低Storage服务的扫描性能，以及占用更多内存。建议您将索引长度设置为和要被索引的最长字符串相同。索引长度最长为255，超过部分会被截断。"

!!! warning "如果已经为标签或边类型中的任何属性创建了索引，不要再为标签或边类型本身创建索引。"

## 创建标签/边类型索引

```ngql
nebula> CREATE TAG INDEX player_index on player();
```

```ngql
nebula> CREATE EDGE INDEX like_index on like();
```

为标签或边类型创建索引后，您可以使用 `LOOKUP` 语句查找`带有该标签的`所有点的VID，或者`所有该类型的边`的`对应起始点VID、目的点VID、以及rank`。详情请参见[LOOKUP](../7.general-query-statements/5.lookup.md)。

## 创建单属性索引

```ngql
nebula> CREATE TAG INDEX player_index_0 on player(name(10));
```

上述示例是为所有包含标签`player`的点创建属性`name`的索引，索引长度为10。即只使用属性`name`的前10个字符来创建索引。

```ngql
# 变长字符串需要指定索引长度。
nebula> CREATE TAG var_string(p1 string);
nebula> CREATE TAG INDEX var ON var_string(p1(10));

# 定长字符串不需要指定索引长度。
nebula> CREATE TAG fix_string(p1 FIXED_STRING(10));
nebula> CREATE TAG INDEX fix ON fix_string(p1);
```

```ngql
nebula> CREATE EDGE INDEX follow_index_0 on follow(degree);
```

## 创建复合属性索引

`复合属性索引`用于查找一个标签(或者边类型)中的多个属性（的组合）。

!!! warning "不支持跨越多个标签(或边类型)的属性来创建复合索引。复合属性索引只能针对同一个标签上多个属性的组合。"

```ngql
nebula> CREATE TAG INDEX player_index_1 on player(name(10), age);
```

!!! note
   
    复合属性索引被(`LOOKUP 或者 `MATCH`)使用时，遵循"最左匹配原则"，必须从复合属性索引的最左侧开始匹配。
    
请参见下方示例。

```ngql
# 为标签t的前三个属性创建复合属性索引。
nebula> CREATE TAG INDEX example_index ON TAG t(p1, p2, p3);

# 注意：无法匹配到索引，因为不是从p1开始。
nebula> LOOKUP ON t WHERE p2 == 1 and p3 == 1; 

# 可以匹配到索引。
nebula> LOOKUP ON t WHERE p1 == 1;  
# 可以匹配到索引，因为p1和p2是连续的。
nebula> LOOKUP ON t WHERE p1 == 1 and p2 == 1;  
# 可以匹配到索引，因为p1、p2、p3是连续的。
nebula> LOOKUP ON t WHERE p1 == 1 and p2 == 1 and p3 == 1; 
```
